import { ChildProcess } from "child_process";
import { readFileSync, writeFileSync } from "fs";
import { safeDump, safeLoad } from "js-yaml";
import { basename, dirname, extname, join } from "path";
import { mkdir, rm } from "shelljs";
import APTerminal from "./terminal";

/**
 * Config details for Analysis Class.
 * @param template File path after ConfigFiles directory
 * @param changes Changes to config file options (optional)
 */
interface AnalysisConfig {
  template: string;
  changes?: {};
}

/**
 * AP analysis types
 */
export enum AnalysisProcessingType {
  audio2csv = "audio2csv",
  audio2sonogram = "Audio2Sonogram",
  indiciesCsv2image = "IndiciesCsv2Image"
}

/**
 * AP analysis options
 */
export interface AnalysisOptions {
  "--temp-dir"?: string;
  "--offset"?: string;
  "--align-to-minute"?: AnalysisAlignToMinute;
  "--channels"?: string;
  "--mix-down-to-mono"?: AnalysisMixDownToMono;
  "--parallel"?: boolean;
  "--when-exit-copy-log"?: boolean;
  "--when-exit-copy-config"?: boolean;
  "--log-level"?: AnalysisLogLevel;
}

/**
 * AP analysis mix down to mono option
 */
export enum AnalysisMixDownToMono {
  False = "false",
  True = "true"
}

/**
 * AP analysis align to minute options
 */
export enum AnalysisAlignToMinute {
  noAlignment = "No Alignment",
  trimBoth = "TrimBoth",
  trimNeither = "TrimNeither",
  trimStart = "TrimStart",
  trimEnd = "TrimEnd"
}

/**
 * AP analysis log level options
 */
export enum AnalysisLogLevel {
  none = "0",
  error = "1",
  warn = "2",
  info = "3",
  debug = "4",
  trace = "5",
  verbose = "6",
  all = "7"
}

/**
 * This class manages all the details required to perform a single analysis using AP.
 */
export class AnalysisItem {
  /**
   * Create singular analysis item
   * @param type Analysis Type
   * @param label Analysis label
   * @param audio Audio file
   * @param config Config file
   * @param output Output folder
   * @param options Terminal arguments
   */
  constructor(
    public readonly type: string,
    public readonly label: string,
    public readonly audio: string,
    public readonly config: string,
    public readonly output: string,
    public readonly options: string[]
  ) {}

  getAudioBasename(): string {
    return basename(this.audio);
  }

  spawn(): ChildProcess {
    const args: string[] = [];
    args.push(this.audio);
    args.push(this.config);
    args.push(this.output);

    this.options.map(option => {
      args.push(option);
    });

    return APTerminal.spawn(this.type, args);
  }
}

/**
 * This class manages all the details required to perform a group of analyses using AP.
 */
export class AnalysisType {
  private static readonly CONFIG_DIRECTORY = join(
    APTerminal.apFolder,
    "ConfigFiles"
  );

  /**
   * Manages analysis object to interface with the clients terminal
   * @param type Type of analysis
   * @param label Display label for analysis
   * @param configFile Configuration for analysis
   * @param shortDescription Short description of analysis
   * @param description Description of analysis
   * @param options Advanced options for analysis
   */
  constructor(
    public readonly type: AnalysisProcessingType,
    public readonly label: string,
    public readonly configFile: AnalysisConfig,
    public readonly shortDescription: string,
    public readonly description: string,
    public readonly options: AnalysisOptions,
    public audioFiles: string[] = [],
    public config: object = {},
    public output: string = ""
  ) {
    // TODO Find the configFile path from ap/ConfigFiles. Eg. /RecognizerConfigFiles/Ecosounds.MultiRecognizer.yml
    // This is required as the config file assumes the location is from the /ConfigFiles directory
  }

  /**
   * Cleans up all temporary files generated by generateBatch
   */
  public static cleanupTemporaryFiles(): void {
    rm("-r", AnalysisType.CONFIG_DIRECTORY + "/*AP_DESKTOP_TEMP*");
  }

  public generateBatch(): AnalysisItem[] {
    // Read config file
    if (this.config === {}) {
      this.setConfig(this.getConfig());
    }

    // Apply changes to config
    if (this.configFile.changes) {
      this.updateConfigValues(this.config, this.configFile.changes);
    }

    // Generate inputs for analysis
    const timestamp: number = Date.now();
    const temporaryConfig = this.createTemporaryConfigFile(timestamp);
    const generatedOptions = this.generateOptions();

    // Create array of AnalysisItems
    const analysisBatch: AnalysisItem[] = [];
    this.audioFiles.map(audioFile => {
      analysisBatch.push(
        new AnalysisItem(
          this.type,
          this.label,
          audioFile,
          temporaryConfig,
          this.createOutputFolder(timestamp, audioFile),
          generatedOptions
        )
      );
    });

    return analysisBatch;
  }

  /**
   * Get JSON schema of file
   */
  public getConfig(): object {
    const configFilePath = join(
      AnalysisType.CONFIG_DIRECTORY,
      this.configFile.template
    );
    try {
      const file = readFileSync(configFilePath);
      return safeLoad(file.toString());
    } catch (err) {
      console.error("Failed to read config file: " + configFilePath);
      console.error(err);
      throw Error(err);
    }
  }

  public setConfig(config: object): void {
    this.config = config;
  }

  /**
   * Generate options from option list
   */
  private generateOptions(): string[] {
    const output: string[] = [];
    for (const option in this.options) {
      switch (typeof this.options[option]) {
        case "boolean":
          output.push(option);
          break;

        default:
          // Check if option contains a space
          if (this.options[option].indexOf(" ") > -1) {
            output.push(`${option}="${this.options[option]}"`);
          } else {
            output.push(`${option}=${this.options[option]}`);
          }
          break;
      }
    }

    return output;
  }

  /**
   * Create the output folder specific to the analysis and return the folder path
   * @param audioFile Audio file path
   * @returns Output folder path
   */
  private createOutputFolder(timestamp: number, audioFile: string): string {
    const outputFolder: string = join(
      this.output,
      this.label + "(" + timestamp + ")",
      basename(audioFile, extname(audioFile))
    );

    mkdir("-p", outputFolder);

    return outputFolder;
  }

  /**
   * Create a temporary config file for use by AnalyseItem
   * TODO Handle error if temporary file not created
   */
  private createTemporaryConfigFile(timestamp: number): string {
    // Place the temp file inside the same folder as the template config file
    const tempFilename = `${basename(
      this.configFile.template,
      ".yml"
    )}.AP_DESKTOP_TEMP.${timestamp}.yml`;
    const tempDirectory = dirname(
      join(AnalysisType.CONFIG_DIRECTORY, this.configFile.template)
    );
    const tempFilePath = join(tempDirectory, tempFilename);

    try {
      writeFileSync(tempFilePath, safeDump(this.config), { mode: 0o755 });
    } catch (err) {
      console.error("Failed to write temporary config file: " + tempFilePath);
      console.error(err);
      throw Error(err);
    }
    return tempFilePath;
  }

  /**
   * Update the config values with the custom changes
   * @param config Config values
   * @param configChanges Changes to config
   */
  private updateConfigValues(config: {}, configChanges: {}): void {
    for (const value in configChanges) {
      if (typeof configChanges[value] === "object") {
        this.updateConfigValues(config[value], configChanges[value]);
      } else {
        config[value] = configChanges[value];
      }
    }
  }
}
